<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <meta name="Generator" content="Malte Kosian">
  <meta name="Author" content="Malte Kosian">
  <meta name="Keywords" content="adventure, game, story, story game, editor, simple, kiss, choice, yes, you can">
  <meta name="Description" content="a grid based linear story game with many choices">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>Grid Story Game</title>
  <style>
  body {background: #fff; margin: 0; overflow: hidden;}

  .grid-ready,.grid-end,.grid-element,.grid-start{
  float:left;background:#ccc;border:0px solid #000;margin:5px;width:0px;height:0px;display:none;
  }
  .grid-start{background:#0c0;}
  .grid-end{background:#c00;}
  .grid-ready{background:#99c;}
  .grid-current{border-color:#f90;}
  .prompt{position: absolute; left: 5%; top: 5%; min-width: 83%;max-width: 83%; min-height: 83%;max-height: 83%; padding: 1%; z-index: 100; display: block; overflow: auto; background: rgba(204,204,204,0.75); color: #000; box-shadow: 5px 5px 8px #999, 0px 0px 1px #000;}
  /*.ingame-visible{display: block;}*/
 </style>
 <!--
 The title:
 Hurry, you are too late. To your job as quick as possible!
 The correct order:
 1  Wake and stand up in the morning.   showObject(16);
 2  Turn on the lights.                 showText('Say hello to the world!');showObject(3);showObject(8);
 3  Go to the kitchen.                  showObject(4);showObject(10);showObject(9);
 4  Open the water tap.                 showObject(5);showObject(6);
 5  Make coffee.                        showObject(14);
 6  Have breakfast.                     showObject(7);
 7  Put the dishes in the sink and close the tap.
 8  Go to the bath.                     showObject(12);
 9  Take a shower.                      showObject(13);
 10 Brush your teeth.                   showObject(11);
 11 Dry yourself off with the towel     showText('You really have to hurry now!')
 12 Don't panic!                        showObject(15);
 13 Get yourself dressed.
 14 Fetch the keys.
 15 Turn off the lights.
 16 Leave your home.
 -->
 <!--
 the dependencies:
 hasMissed:
 1 -> NOT possible!
 2 -> Seriously! You break your arms and legs. 5 years later someone will find your dead body. You will be reborn as yourself.
 3 -> no breakfast like 6.
 4 -> you can not have coffee without water. You are still dreaming. You are to late and you loose your job.
 5 -> like 6
 6 -> without a breakfast you will fall asleep again. You loose your job.
 7 -> your landlord will recall the contract, because of the water damage. So you have a very long day and have to stay in a hotel. Next day you'll loose your job, because you'll have overslept.
 8 -> you will miss 9,10,11...
 9 -> you stink. A good reason for your boss to fire you.
 10 -> your mouth stinks. A good reason for your boss to fire you.
 11 -> you get a cold. The very next day you loose your job, because your boss do not believes you.
 12 -> you are in panic, so 13, 14 and 15 takes place. You've lost the game and will be reborn as yourself.
 13 -> you are naked. The neighbor sees you and calls the police. After 5 years in the psychiatry you'll way to late.
 14 -> you will have to wait for the key service. You loose your job, because you are to late.
 15 -> the house will burn done. So you have a very long day and have to stay in a hotel. Next day you'll loose your job, because you'll have overslept.
 16 -> NOT possible.
 isSmaller:
 8 < 3 Bath before kitchen like -> 11.
 15 < 14 you do not take your keys. You have taken your mobile instead. Like -> 14
 13 < 12 You are in panic. like -> 13
 5 < 4 like -> 4
 -->
 <!--
 long story:
 stand up in the morning
 catch the bus and the underground (anyway you'll be late - if you do not take the bus you will walk to the u-station)
 loose your job and get the one as a game designer
 play the help file
 use the game's editor and write your own small game.
 -->
 <!--
 Even in pure linear story of a game the problem is how to dramatize the story,
 how to synchronize the events and what to reveal next.
 You have to give the player choices so the player can make mistakes.
 It is indeed all about mistakes, because the logical order is both inherit and
 explicit. The logical order is clear - afterwards. Only mistakes
 provide the challange to the player, the drama of the psychological conflict.
 -->
 <!--
 BUGS:

 TODOS:
 -> find a way to edit the evaluation tool, dependicies and the reporting output
    2 smaler 1 -> you made something in the wrong order

 make the complete tool canvas based
 build in uidcounter
 enable levels (transform game to level)
 enable level to level methods -> what will be the advanced features?
 game states and/or status-log
 build in mediamanager
 images, audios, translator
 object sizing and position
 DONE
 ?FIX? game.order must be reintialized after one play
 ?FIX? adding to order only once and NOT is if a object is only clicked(except the start object)
 fixed 2 out of 16 -> the length is way to short  (you left to early look for missed definitions)
 fixed 2 missed -> you did not do something (like leaving without key)
 fixed 2. define and detect cases -> show message - may loop to begining (rebirth after death)
 fixed evaluation on game.over for cases isSmaller and hasMissed
 fixed evaluation 1. game.over message and statistic evaluation
 fixed what to reveal next with showEvent code -> showObject, hideObject, showText(a message)
 fixed showObject set GameObject.active to true
 fixed GameObject.active if false not visible and playable
 fixed added Game method for mouse|touch Game.init and update and Game.draw
 fixed bug with Game.prototype.load method in editor.loadGame method
 fixed need to load the stuff on start AND update the layout/editor view indeed!
 fixed ask for the quest on start up. SHOW the quest and the title!
 fixed output layout
 fixed output updates
 -->
 </head>
 <body>
  <script>
  (function(win) {
    /**
    @class MediaLanguage
    @param _lan
    @since 2014-05-18
    */
    function MediaLanguage(_lan) {
      /**
      @attribute language
      */
      this.language = _lan;
      /**
      @property medias
      */
      this.medias = [];
      /**
      @method load
      @param data
      @since 2014-05-29
      */
      this.load = function(data) {
      this.language = data['language'];
      this.medias = [];
      for (var i = 0; i < data['medias'].length; i++) {
       this.medias.push({ key:data['medias'][i]['key'], value:data['medias'][i]['value']});
      }
      };
      /**
      _t64 indicates if the value has to be base64_encoded or not
      @method setMedia
      @since 2014-05-15
      @param _k the key
      @param _v the value
      @param {boolean} _t64 to be 64 encoded
      */
      this.setMedia = function(_k, _v, _t64) {
      //console.log('setMedia'+_k);
      if (this.hasMedia(_k)) {
       this.getMedia(_k).value = _t64 ? btoa(_v): _v;
      } else {
       this.addMedia(_k, _v, _t64);
      }
      };
      /**
      use this to get Images, Audios, Videos and other
      media that should stay bas64 encoded
      var myMediaValue = [..].getMedia('key').value;
      @method getMedia
      @since 2014-05-15
      @param _k the key
      @return the complete media Object
      */
      this.getMedia = function(_k) {
        for (var i = 0; i < this.medias.length; i++) {
          if (this.medias[i].key == _k) {
            return this.medias[i];
          }
        }
        return null;
      };
      /**
      Don't use this method for images, audios or videos,
      because those have to stay base64_encoded
      @method getTextMedia
      @since 2014-05-15
      @param _k the key
      @return the media value - always base64 decoded
      */
      this.getTextMedia = function(_k) {
        for (var i = 0; i < this.medias.length; i++) {
          if (this.medias[i].key == _k) {
            //console.log('getMedia->'+atob(this.medias[i].value));
            return atob(this.medias[i].value);
          }
        }
        return null;
      };
      /**
      @method hasMedia
      @since 2014-05-15
      @param _k the key
      @return {boolean} true if the media with the key exists
      */
      this.hasMedia = function(_k, _v) {
        for (var i = 0; i < this.medias.length; i++) {
          if (this.medias[i].key == _k) {
            return true;
          }
        }
        return false;
      };
      /**
      @method deleteMedia
      @since 2014-05-16
      @param _k the key
      */
      this.deleteMedia = function(_k, _v) {
        for (var i = 0; i < this.medias.length; i++) {
          if (this.medias[i].key == _k) {
            return this.medias.splice(i, 1);
          }
        }
      };
      /**
      @method addMedia
      @since 2014-05-15
      @param _k the key
      @param _v the value
      @param {boolean} _t64 to be 64 encoded
      */
      this.addMedia = function(_k, _v, _t64) {
        this.medias.push(this.createMedia(_k, _v, _t64));
      };
      /**
      @method createMedia
      @since 2014-05-15
      @param _k the key
      @param _v the value
      @param {boolean} _t64 to be 64 encoded
      @return the media Object
      */
      this.createMedia = function(_k, _v, _t64) {
        _v = _t64 ? btoa(_v): _v;
        return { key : _k, value : _v };
      };
    };
    var Game = function(){};
    Game.prototype.start = null;
    Game.prototype.end = null;
    Game.prototype.objects = [];
    /*
    {priority: 0, method:'isSmaller', text: 'show this text', params: [a,b]}
    {priority: 1, method:'hasMissed', text: 'show this text because of the higher priority', params: [a]}
    */
    Game.prototype.dependencies = [];
    Game.prototype.current = null;
    Game.prototype.order = [];
    Game.prototype.title = null;
    //maybe the quest will be an object instead of a simple string
    //so the quest will be validated in the end of the level/game
    Game.prototype.quest = null;
    Game.prototype.over = false;
    /**
    @method getObject
    @param id the id of the object
    @return the object
    */
    Game.prototype.getObject = function(id) {
      var objects = this.objects;
      for (var i = 0; i < objects.length; i++)
      {
        if (objects[i].id==id)
        {
          return objects[i];
        }
      }
      return null;
    };
    /**
    activate the Object and make it always visible
    @method showObject
    @param id the id of the object
    */
    Game.prototype.showObject = function(id) {
      var obj = this.getObject(id);
      console.log('showObject->',id,obj);
      obj.visible = true;
      obj.active = true;
      //game.currentText = null;
    };
    /**
    hide the Object complete on visible false
    otherwise it is deactivated
    @method hideObject
    @param id the id of the object
    @param visible
    */
    Game.prototype.hideObject = function(id,visible) {
      var obj = this.getObject(id);
      obj.visible = visible;
      obj.active = false;
      //game.currentText = null;
    };
    /**
    display the given text
    @method showText
    @param text display the given text
    */
    Game.prototype.showText = function(text) {
      //displays the text on the canvas
      //canvas and ctx are attached to the window
      console.log('showText='+atob(text));
      game.currentText = atob(text);
    };
    /**
    a dependencies method
    if the order of a is smaller than the order of b
    @method isSmaller
    @param a
    @param b
    */
    Game.prototype.isSmaller = function(a, b) {
     //code here
    };
    /**
    a dependencies method
    if you have missed the object specified by id
    @method hasMissed
    @param a
    */
    Game.prototype.hasMissed = function(a) {
     //code here
    };
    /**
    follows touch and mouse event
    @method mousePressed
    @param x the x coordinate in 0 to 1 .
    @param y the y coordinate in 0 to 1 .
    */
    Game.prototype.mousePressed = function(x,y) {
      if (!pressed)
      {
        pressed = true;
        var obj = null;
        for (var i = 0; i < game.objects.length; i++) {
          obj = game.objects[i];
          if (obj.pointHits(x,y) && obj.active) {
            game.current = obj;
          }
        }
        px = x;
        py = y;
        mx = x;
        my = y;
        update = true;
      }
    };
    /**
    follows touch and mouse event
    @method mouseMoved
    @param x the x coordinate in 0 to 1 .
    @param y the y coordinate in 0 to 1 .
    */
    Game.prototype.mouseMoved = function(x,y) {
      if (pressed)
      {
        if (game.current != null)
        {
          game.current.x += x-game.current.x;
          game.current.y += y-game.current.y;
          update = true;
        }
      }
    };
    /**
    follows touch and mouse event
    @method mouseReleased
    @param x the x coordinate in 0 to 1 .
    @param y the y coordinate in 0 to 1 .
    */
    Game.prototype.mouseReleased = function(x,y) {
      if (pressed)
      {
        //game.menumode false|true
        if (!game.over) {
          if (game.current != null && game.start != null && (
              (game.current.id != game.start &&
              game.getObject(game.start).pointHits(game.current.x+game.current.w/2, game.current.y+game.current.h/2)) ||
              (game.end != null && game.current.id == game.start &&
              game.getObject(game.end).pointHits(game.current.x+game.current.w/2, game.current.y+game.current.h/2))
             ))
          {
            if (game.current.id == game.start &&
               game.getObject(game.end).pointHits(game.current.x+game.current.w/2, game.current.y+game.current.h/2)
               )
            {
              game.current = game.getObject(game.end);
            }
            if (game.order.indexOf(game.current.id) < 0) {
              game.order.push(game.current.id);
            }
            game.current.active = false;
            game.current.visible = false;
            if (game.current.events != null) {
              game.current.getEvent();
            }
            if (game.current.id == game.end) {
              game.over = true;
            }
          } else if (game.current != null && game.current.id == game.start &&
                     game.getObject(game.start).pointHits(game.current.ox+game.current.w/2, game.current.oy+game.current.h/2)
                    )
          {
            if (game.order.indexOf(game.current.id) < 0) {
              game.order.push(game.current.id);
            }
            if (game.current.events != null) {
              game.current.getEvent();
            }
          } else if (game.current != null)
          {
            game.current.x = game.current.ox;
            game.current.y = game.current.oy;
          }
        } else {

        }
        px = 0;
        py = 0;
        mx = 0;
        my = 0;
        game.current = null;
        pressed = false;
        update = true;
      }
    };
    /**
    used by editor.playGame this to start a game
    use editor.stopGame to finish the game
    @method init
    */
    Game.prototype.init = function() {
      var obj = null;
      for (var i = 0; i < 4; i++)
      {
        for (var j = 0; j < 4; j++)
        {
          obj = game.getObject('o_'+i+'_'+j);
          obj.x = 0.04 + j * 0.24;//canvas.width/40 + j * canvas.width/4.5;
          obj.y = 0.04 + i * 0.24;//canvas.width/8 + i * canvas.width/4.5;
          obj.w = obj.h = 0.2;//canvas.width/6;
          obj.ox = obj.x;
          obj.oy = obj.y;
          obj.visible = true;
        }
      }
      game.over = false;
      if ('ontouchstart' in window)
      {
        console.log('using touch');
        canvas.addEventListener('touchstart',
        function(eve) {
          game.mousePressed(eve.touches[0].pageX/canvas.width,
            eve.touches[0].pageY/canvas.width);
        },
        false);
        canvas.addEventListener('touchmove',
        function(eve) {
          game.mx = eve.touches[0].pageX/canvas.width;
          game.my = eve.touches[0].pageY/canvas.width;
          game.mouseMoved(game.mx,game.my);
        },
        false);
        canvas.addEventListener('touchend',
        function(eve) {
          if (!game.mend) {
            game.mend = true;
            game.mouseReleased(game.mx, game.my);
          }
        },
        false);
        canvas.addEventListener('touchcancel',
        function(eve) {
          if (!game.mend) {
            game.mend = true;
            game.mouseReleased(game.mx, game.my);
          }
        },
        false);
      }
      canvas.addEventListener('mousedown',
      function(eve) {
        game.mousePressed(eve.pageX/canvas.width,
          eve.pageY/canvas.width);
      },
      false);
      canvas.addEventListener('mousemove',
      function(eve) {
        game.mx = eve.pageX/canvas.width;
        game.my = eve.pageY/canvas.width;
        game.mouseMoved(game.mx,game.my);
      },
      false);
      canvas.addEventListener('mouseup',
      function(eve) {
        game.mouseReleased(eve.pageX/canvas.width,
          eve.pageY/canvas.width);
      },
      false);

      update = true;
      requestAnimationFrame(function() { game.updateGraphics(); });
    };
    /***/
    Game.prototype.updateGraphics = function() {
      if (update)
      {
        update = false;
        game.draw();
      }
      requestAnimationFrame(function() { game.updateGraphics(); });
    };
    /**
    formats the text onliner in a readable and screen fitting text array
    @method formatText
    @param the text to format
    @return the line formated text-array
    */
    Game.prototype.formatText = function(text) {
      var ctext = [];
      var line = '';
      text = text.split(' ');
      for (var i = 0; i < text.length; i++)
      {
        if (ctx.measureText(line+' '+text[i]).width <= canvas.width * 0.9)
        {
          if (line.length > 0) {
            line = line+' '+text[i];
          } else {
            line = text[i];
          }
        } else {
          ctext.push(line);
          line = text[i];
        }
      }
      //push the last line here and now ->
      ctext.push(line);
      console.log('ctext -> ',ctext);
      return ctext;
    };
    /**
    @method getDependency
    */
    Game.prototype.getDependency = function(method, obj_id) {
      var depend = null;
      for (var i = 0; i < this.dependencies.length; i++) {
        depend = this.dependencies[i];
        if (depend.method != null && depend.method == method &&
            depend.params.length > 0 && depend.params[0] == obj_id)
        {
          return depend;
        }
      }
      return null;
    }
    /**
      @class mediamanager
      @since 2014-05-18
    */
    Game.prototype.mediamanager = {
      /**
      @property defaultLananguage
      @default 'en'
      */
      defaultLanguage : 'en',
      /**
      @property currentLanguage
      @default 'en'
      */
      currentLanguage : 'en',
      /**
      @property {array} languages
      */
      languages : [],
      /**
      @property {array} mediaLanguages
      */
      mediaLanguages : [],
      /**
      @method setCurrentLanguage
      */
      setCurrentLanguage : function(_lan) {
        this.currentLanguage = _lan;
        if (!this.hasLanguage(_lan)) {
          this.addLanguage(_lan);
        }
      },
      /**
      @method addLanguage
      */
      addLanguage : function(_lan) {
        this.mediaLanguages.push( new MediaLanguage(_lan) );
        this.languages.push(_lan);
      },
      /**
      @method hasLanguage
      */
      hasLanguage : function(_lan) {
        for (var i = 0; i < this.languages.length; i++) {
          if (this.languages[i] == _lan) {
            return true;
          }
        }
        return false;
      },
      /**
      @method getLanguage
      @since 2014-07-31
      @param _lan a language key like 'en','de',...
      @return {MediaLanguage} a mediaLanguage or null
      */
      getLanguage : function(_lan) {
        for (var i = 0; i < this.mediaLanguages.length; i++) {
          if (this.mediaLanguages[i].language == _lan) {
            return this.mediaLanguages[i];
          }
        }
        return null;
      },
      /**
      @method getCurrentLanguage
      */
      getCurrentLanguage : function() {
        for (var i = 0; i < this.mediaLanguages.length; i++) {
          if (this.mediaLanguages[i].language == this.currentLanguage) {
            return this.mediaLanguages[i];
          }
        }
        this.currentLanguage = this.defaultLanguage;
        var language = new MediaLanguage(this.currentLanguage);
        this.mediaLanguages.push( language );
        this.languages.push(this.currentLanguage);
        return language;
      },
      /**
      returns the keys, defined by the default language
      @method getKeys
      @since 2914-07-31
      @return {Array} keys
      */
      getKeys : function () {
        var d_lan = this.getLanguage(this.defaultLanguage);
        var keys = [];
        for (var i = 0; i < d_lan.medias.length; i++) {
          //console.log(d_lan.getMedia(d_lan.medias[i].key).value.substr(0, 20));
          if (!(d_lan.getMedia(d_lan.medias[i].key).value.indexOf('data:') == 0 &&
              d_lan.getMedia(d_lan.medias[i].key).value.indexOf('base64') > 0))
          {
            keys.push(d_lan.medias[i].key);
          }
        }
        return keys;
      },
      /**
      use getTextMedia too get the decoded media value
      @method setTextMedia
      @since 2014-05-17
      @param _k the key
      @param _v the value
      */
      setTextMedia : function(_k, _v) {
        //type64=true|false would regulate de/encoding or not
        for (var i = 0; i < this.mediaLanguages.length; i++) {
          if (this.mediaLanguages[i].getMedia(_k) == null) {
            this.mediaLanguages[i].setMedia(_k, _v, true);
          }
        }
      },
      /**
      push through for MediaLanguage.setMedia
      the media will not be base64 encoded
      use getMedia too get the media
      use for Images and other natually base64 encoded media
      @method setMedia
      @since 2014-05-29
      @param _k the key
      @param _v the value - already base64 encoded
      */
      setMedia : function(_k, _v) {
        //type64=true|false would regulate de/encoding or not
        for (var i = 0; i < this.mediaLanguages.length; i++) {
          if (this.mediaLanguages[i].getMedia(_k) == null) {
            this.mediaLanguages[i].setMedia(_k, _v, false);
          }
        }
      },
      deleteMedia : function(_k) {
        for (var i = 0; i < this.mediaLanguages.length; i++) {
          this.mediaLanguages[i].deleteMedia(_k);
        }
      },
      getMedia : function(_k) {
        return this.getCurrentLanguage().getMedia(_k);
      },
      getTextMedia : function(_k) {
        return this.getCurrentLanguage().getTextMedia(_k);
      },
      /**
      @method load
      @param data
      @since 2014-05-29
      */
      load : function(data) {
        this.defaultLanguage = 'en',
        this.currentLanguage = data['currentLanguage'];
        this.languages = data['languages'];
        this.mediaLanguages = [];
        for (var i = 0; i < data['mediaLanguages'].length; i++) {
          var lan = new MediaLanguage(data['mediaLanguages'][i]['uid']);
          lan.load(data['mediaLanguages'][i]);
          this.mediaLanguages.push(lan);
        }
      }
    };
    /**
    @method draw
    */
    Game.prototype.draw = function() {
      var cw = canvas.width;
      var ch = canvas.height;
      ctx.fillStyle = '#eee';
      ctx.fillRect(0,0,cw,ch);
      ctx.fillStyle = '#000';
      var fts = Math.round(0.035*cw);
      ctx.font = fts+'px Sans-Serif';
      var objects = game.objects;
      var obj = null;
      if (game.over)
      {
        ctx.fillText(''+atob(game.title),0.02*cw,(0.01*cw+fts)*1);
        ctx.fillText('statistics:',0.02*cw,(0.01*cw+fts)*2);
        var missed = objects.length - game.order.length;
        if (missed > 0)
        {
          //ctx.fillText('You have missed '+missed+' step'+(missed>1 ? 's':''),0.02*cw,(0.01*cw+fts)*3);
          var cprior = 0;
          var ctext = [];
          for (var i = 0; i < objects.length; i++) {
            obj = objects[i];
            if (game.order.indexOf(obj.id) < 0)
            {
              console.log(obj.id);
              ctx.fillStyle = '#c00';
              //ctx.fillText(obj.id+' '+obj.order,0.02*cw,(0.01*cw+fts)*(4+i));
              var dep = game.getDependency('hasMissed',obj.id);
              if (dep != null && cprior < dep.priority) {
                cprior = dep.priority;
                ctext = game.formatText(atob(dep.text));
              }
            }
          }
          //hasMissed
          for (var j = 0; j < ctext.length; j++) {
            ctx.fillText(ctext[j],0.02*cw,(0.01*cw+fts)*(4+j));
          }
        } else {
          for (var i = 0; i < game.order.length; i++) {
            obj = game.getObject(game.order[i]);
            console.log(obj);
            if (obj.order == 1 || (i >= 1 && obj.order > game.getObject(game.order[i-1]).order)) {
              ctx.fillStyle = '#0c0';
            } else {
              ctx.fillStyle = '#c00';
            }
            ctx.fillText(obj.id+' '+obj.order,0.02*cw,(0.01*cw+fts)*(3+i));
          }
          //isSmaller
        }
      } else {
        ctx.fillText(''+atob(game.title),0.02*cw,0.01*cw+fts);
        ctx.fillText(''+atob(game.quest),0.02*cw,(0.01*cw+fts)*2);
        //begin of btx context
        ctx.lineWidth = 0.025 * cw;
        for (var i = 0; i < objects.length; i++)
        {
          obj = objects[i];
          if (obj.visible) {
            if (obj.id == game.start)
            {
              ctx.fillStyle = '#0c0';
              ctx.strokeStyle = '#000';
            } else if (obj.id == game.end)
            {
              if (obj.active)
              {
                ctx.fillStyle = '#c00';
                ctx.strokeStyle = '#000';
              } else {
                ctx.fillStyle = 'rgba(204,51,51,0.5)';
                ctx.strokeStyle = 'rgba(51,51,51,0.5)';
              }
            } else if (obj.active)
            {
              ctx.fillStyle = '#99c';
              ctx.strokeStyle = '#000';
            } else {
              ctx.fillStyle = 'rgba(128,128,128,0.5)';
              ctx.strokeStyle = 'rgba(51,51,51,0.5)';
            }
            if (game.current != null && obj.id == game.current.id) {
              ctx.strokeStyle = '#f90';
            }
            ctx.fillRect(obj.x * cw, obj.y * cw, obj.w * cw, obj.h * cw);
            ctx.strokeRect(obj.x * cw, obj.y * cw, obj.w * cw, obj.h * cw);
          }
        }
        //end of btx context
        ctx.fillStyle = '#000';
        var fts = Math.round(0.035*cw);
        ctx.font = fts+'px Sans-Serif';
        ctx.fillText(''+atob(game.title),0.02*cw,0.01*cw+fts);
        ctx.fillText(''+atob(game.quest),0.02*cw,(0.01*cw+fts)*2);
        if (game.current != null) {
          ctx.fillText(''+game.current.getText(),0.02*cw,(0.01*cw+fts)*3);
        } else if (game.order.length > 0) {
          var j = 0;
          for (var i = game.order.length - 1; i >= (game.order.length > 2 ? game.order.length-3 : 0); i--) {
            ctx.fillText(''+game.getObject(game.order[i]).getText(),0.02*cw,
                    (0.01*cw+fts)*((game.order.length > 2 ? 3 : game.order.length)+(2-j)));
            j++;
          }
          if (game.currentText!= null) {
            ctx.fillText(''+game.currentText,0.02*cw,(0.01*cw+fts)*6.25);
          }
        }
      }
    };
    var mx = 0;
    var my = 0;
    var px = 0;
    var py = 0;
    var pressed = false;
    var mend = false;
    var update = false;
    var body = document.body;
    var store = localStorage;
    var menuMode = false;
    var gmode = 'editor';
    var bufferImg = null;
    var btx = null;
    var mouseTimer = null;
    var canvas = null;
    var ctx = null;
    /*
    short for game.showObject (Game.prototype.showObject)
    a scriptable function
    @method showObject
    @param id
    /
    win.showObject = function (id) {
      game.showObject(id);
    }
    /
    short for game.hideObject (Game.prototype.hideObject)
    a scriptable function
    @method hideObject
    @param id
    /
    win.hideObject = function (id) {
      game.hideObject(id);
    }
    /
    short for game.showText (Game.prototype.showText)
    a scriptable function
    @method showText
    @param id
    /
    win.showText = function (text) {
      game.showText(text);
    }
    /
    short for game.isSmaller
    @method isSmaller
    @param a
    @param b
    /
    win.isSmaller = function (a, b) {
      game.isSmaller(a, b);
    }
    /
    short for game.hasMissed
    @method hasMissed
    @param a
    /
    win.hasMissed = function (a) {
      game.hasMissed(a);
    }*/
    /**
    short for document.getElement
    @method getElement
    @param t the id
    @return the HTMLdomObject
    */
    win.getElement = function(t){
      return document.getElementById(t);
    };
    /**
    short for document.createElement
    @method createElement
    @param t the descriptor of the tag|the tag
    @return the HTMLdomObject
    */
    function createElement(t){
      return document.createElement(t);
    };
    /**
    short for document.createTextNode
    @method createTextNode
    @param t the text
    @return the HTMLdomTextNode
    */
    function createTextNode(t){
      return document.createTextNode(t);
    };

    /**
    @class GameObject
    */
    var GameObject = function (_id, _t) {
      this.text = btoa(_t);
      this.order = 0;
      this.id = _id;
      //this.event = null;
      this.events = [];
      this.active = false;
      this.visible = true;
      this.x = 0;
      this.y = 0;
      this.ox = 0;
      this.oy = 0;
      this.w = 0;
      this.h = 0;
      /**
      call callback function with window, game as parameters
      @method getEvent
      @return the callback function (¿ returns the return value or null ?)
      */
      this.getEvent = function() {
        /*if (this.event == null){
          return null;
        }*/
        try {
          game.currentText = null;
          console.log(this.events);
          for (var i = 0; i < this.events.length; i++) {
            console.log(this.events[i].method,this.events[i].values);
            switch (this.events[i].values.length) {
              case 1:
              game[this.events[i].method](this.events[i].values[0]);
              break;
              case 2:
              game[this.events[i].method](this.events[i].values[0],
              this.events[i].values[1]);
              break;
              case 3:
              game[this.events[i].method](this.events[i].values[0],
              this.events[i].values[1],this.events[i].values[2]);
              break;
              case 4:
              game[this.events[i].method](this.events[i].values[0],
              this.events[i].values[1],this.events[i].values[2],
              this.events[i].values[3]);
              break;
              case 5:
              game[this.events[i].method](this.events[i].values[0],
              this.events[i].values[1],this.events[i].values[2],
              this.events[i].values[3],this.events[i].values[4]);
              break;
              default:
              game[this.events[i].method]();
              break;
            }
          }
        } catch(ex) {
          console.log(ex);
        }
        //return new Function('window,game',atob(this.event));
      }
      /**
      @method setEvent
      @param _code the code to be performed on the clicked|touched|selected event
      */
      this.setEvent = function(_code) {
        /*var events = btoa(_code).split(',');
        for (var i = 0; i < this.events.length; i++)
        {
          console.log(this.events[i][0],this.events[i][1].replace(/)/,''));
          //this.event.push(new GameEvent(this.event[i][0],this.event[i][1].replace(/)/,'')););
        }*/
        //this.event = new GameEvent(this.event[0],this.event[1].replace(/)/,''));
      }
      /**
      @method getText
      */
      this.getText = function() {
        return atob(this.text);
      }
      /**
      @method setText
      */
      this.setText = function(_t) {
        this.text = btoa(_t);
      };
      /**
      @method load
      */
      this.load = function(data) {
        this.text = data['text'];
        this.order = parseInt(data['order']);
        this.id = data['id'];
        //this.event = data['event']==null?null:atob(data['event']);
        this.events=[];
        if (typeof data['events'] != 'undefined')
        for (var i = 0; i < data['events'].length; i++) {
          this.events.push(new GameEvent(data['events'][i]['method'],data['events'][i]['values']));
        }
        /*if (this.event != null)
        {

          //console.log(this.event.split(';'));
          var events = this.event.split(';');
          for (var i = 0; i < (events.length-1); i++)
          {
            events[i] = events[i].split('(');
            var values = events[i][1].replace(/\)/,'').replace(/\'/g,'').split(',');
            if (events[i][0]=='showText') {
              values[0]=btoa(values[0]);
            }
            this.events.push(new GameEvent(events[i][0],values));
          }
        }*/
        //this.event = btoa(this.event);
        this.active = typeof data['active'] == 'undefined' ? false : data['active'];
        this.x = data['x'];
        this.y = data['y'];
        this.ox = data['x'];
        this.oy = data['y'];
        this.w = data['w'];
        this.h = data['h'];
      };
      /**
      @method pointHits
      */
      this.pointHits = function(_x, _y) {
        return (this.x <= _x && this.y <= _y && this.x + this.w >= _x && this.y + this.h >= _y);
      };
    };
    /**
    @class GameEvent
    */
    var GameEvent = function(method, values) {
      this.method = method;
      this.values = values;
    };
    /**
    @class GameDependency
    {priority:'',method:'',params:[]}
    */
    var GameDependency = function(p, method) {
      this.priority = p;
      this.method = method;
      this.text = null;
      this.params = [];//the referenced object by obj_id
      this.event = null; //not used in the moment
      /**
      @method getText
      @return the b64decoded text
      */
      this.getText = function () {
        return atob(this.text);
      };
      /**
      @method setText
      @param text encodes the text base64
      */
      this.setText = function (text) {
        this.text = btoa(text);
      };
      /**
      @method load
      @param data
      */
      this.load = function(data) {
        this.priority = data['priority'];
        this.method = data['method'];
        this.params = data['params'];
        this.text = data['text'];
        if (data['event'] != null) {
          this.event = new GameEvent(data['event']['method'],data['event']['value']);
        } else {
          this.event = null;
        }
      };
    };
    /***/
    //var game = new Game();
    //for debug purpose only
    win.game = new Game();
    //end debug
    /***/
    var editor = {};
    editor.mode = '';
    editor.current = null;
    editor.oldGame = null;
    //editor.currentScene = null;
    editor.currentObject = null;
    //editor.currentDialog = null;
    editor.uidMax = 5;
    editor.dialogMethod = null;
    editor.menuMode = false;
    editor.mediamanager = (new Game()).mediamanager;
    editor.openButtonLabel = null;
    editor.openButtonArray = null;
    editor.buttonLabels = [{text:'set start',onclick:'setStart'},{text:'set end',onclick:'setEnd'},{text:'new game',onclick:'newGame'},{text:'play',onclick:'playGame'},{text:'dependencies',onclick:'showDependenciesPrompt'},{text:'close menu',onclick:'closeMenu'}];
    /**
    calls a prompt
    sets the order for the specified object by id
    and updates the appearence of the editor's output
    @method setOrder
    */
    editor.setOrder = function(_obj_id) {
      if (_obj_id == null && editor.currentObject != null)
      {
        _obj_id = editor.currentObject.id;
      } else if (_obj_id == null && editor.currentObject == null)
      {
        return;
      }
      var obj = game.getObject(_obj_id);
      var input = prompt('Type in a value between 1 to '+(game.objects.length)+' or leave the input as it is', obj.order);
      try
      {
        input = parseInt(input);
      }
      catch (ex)
      {
        alert ('Choose a valid value, please!')
        return;
      }
      if (input < 0 || input > game.objects.length) {
        alert ('Choose a valid value, please!');
        return;
      }
      obj.order = input;
      //var ele = getElement('ord_'+obj.id);
      //ele.innerHTML = '';
      //ele.appendChild(createTextNode(obj.order));
      editor.saveGame();
    };
    /**
    replacement for setOrder and setEvents
    sets the order for the specified object by id
    and updates the appearence of the editor's output
    setting the code for the event
    events are code, but !NOT action model structs [(action name),(value)]!
    @method setOrderAndEvents
    */
    editor.setOrderAndEvents = function(obj_id) {
      var obj=game.getObject(obj_id);
      var input = getElement('input_ord_'+obj_id).value;
      try
      {
        input = parseInt(input);
      }
      catch (ex)
      {
        alert ('Choose a valid value, please!')
        return;
      }
      if (input < 0 || input > game.objects.length) {
        alert ('Choose a valid value, please!');
        return;
      }
      obj.order = input;
      var ele = getElement('ord_'+obj.id);
      ele.innerHTML = '';
      ele.appendChild(createTextNode(obj.order));
      var code = getElement('input_eve_'+obj_id).value;
      //select of method (showObject , hideObject) -> showElement select object (order, id, text) -> set value
      //showText -> show text input -> obj.setText(input.value)
      //event = { action:[methodname], value:[value]}
      //usage call game[event.action](event.value);
      //uses the call action model with predefined actions instead of function(code)
      if (code != '')
      {
        obj.setEvent(code);
      }
      console.log(input,obj.order, code,atob(obj.event));
      editor.saveGame();
      getElement('prompt').style.display = 'none';
    }
    /**
    stores the game if store is available
    if id and text is set this is an initial call
    otherwise it is setting the text
    if id is null and currentObject not set the text of the
    currentObject
    @method setText
    @param id id of the object
    @param text the text for the object
    */
    editor.setText = function(_id,_text){
      if (_id == null && _text == null && editor.currentObject != null)
      {
        _id = editor.currentObject.id;
        _text = null;//?atob()
      } else if (_id == null && editor.currentObject == null)
      {
        alert('Pleae, select the object first!');
        return;
      }
      var obj=game.getObject(_id);
      if (editor.mode=='setstart') {
        /*if (getElement('s_'+game.start)!=null) {
          getElement('s_'+game.start).style.color = '#006';
          getElement(game.start).className = 'grid-ready';
        } else if (game.start!=null) {
          getElement(game.start).className = 'grid-element';
        }*/
        game.start = _id;
        obj.active = true;
        obj.visible = true;
        if (game.start == game.end) {
          game.end=null;
        }
        /*getElement(_id).className = 'grid-start';
        if (getElement('s_'+_id)!=null) {
          getElement('s_'+_id).style.color = '#0c0';
        }*/
        editor.mode = '';
        return;
      }
      if (editor.mode=='setend') {
        /*if (getElement('s_'+game.end)!=null) {
          getElement('s_'+game.end).style.color = '#006';
          getElement(game.end).className = 'grid-ready';
        } else if (game.end!=null) {
          getElement(game.end).className = 'grid-element';
        }*/
        game.end = _id;
        if (game.start == game.end) {
          game.start=null;
        }
        /*getElement(_id).className = 'grid-end';
        if (getElement('s_'+_id)!=null) {
          getElement('s_'+_id).style.color = '#c00';
        }*/
        editor.mode = '';
        return;
      }
      console.log('set text for '+obj.id+' '+_text);
      if (_text==null) {
        if (obj.text==null) {
          _text=prompt('What\'s up next?','');
        } else {
          _text=prompt('What\'s up next?',obj.getText());
        }
      }
      obj.setText(_text);
      if (game.start == null)
      {
        game.start =_id;
        getElement(_id).className='grid-start';
      } //else {

      if (_id != game.start && _id != game.end) {
        //getElement(_id).className='grid-ready';
      } else if (_id == game.start) {
        //getElement(_id).className='grid-start';
      } else if (_id == game.end)
      {
        //getElement(_id).className='grid-end';
      }

      //}
      /*
      var ele = getElement('output');
      var ele2 = getElement('s_'+obj.id);
      if (ele2 == null) {
        ele2 = createElement('span');
        ele2.style.display='inline-block';
        ele2.style.borderBottom='dotted 1px #999';
        ele2.style.marginBottom = '2px';
        ele2.setAttribute('id','s_'+obj.id);
        var span = createElement('span');
        span.style.cssFloat='left';
        span.style.marginRight='1px';
        span.style.display='inline-block';
        span.style.minWidth='40px';
        span.style.border = 'solid 1px #999';
        span.setAttribute('id','ord_'+obj.id);
        span.setAttribute('onclick','editor.showOrderAndEventsPrompt(\''+obj.id+'\');');
        span.appendChild(createTextNode(obj.order));
        ele2.appendChild(span);
        span = createElement('span');
        span.setAttribute('id','s_t_'+obj.id);
        span.setAttribute('onclick', 'editor.showDependenciesPrompt(\''+obj.id+'\');');
        span.appendChild(createTextNode(_text));
        ele2.appendChild(span);
        ele.appendChild(ele2);
        ele.appendChild(createElement('br'));
      } else {
        ele2 = getElement('s_t_'+obj.id);
        ele2.innerHTML = '';
        ele2.appendChild(createTextNode(_text));
        ele2 = getElement('ord_'+obj.id);
        ele2.innerHTML = '';
        ele2.appendChild(createTextNode(obj.order));
      }
      if (_id == game.start) {
        ele2.style.color = '#0c0';
      } else {
        if (_id == game.end) {
          ele2.style.color = '#c00';
        } else {
          ele2.style.color = '#006';
        }
      }*/
      editor.saveGame();
    };
    /**
    @method saveGame
    */
    editor.saveGame = function() {
      try {
        store.setItem('gridStoryGame',JSON.stringify(game));
      } catch (ex) {
        console.log(ex);
      }
    };
    /**
    @method setQuest
    */
    editor.setQuest = function() {
     // var text = prompt('Enter the quest of the game.', game.quest==null?'':atob(game.quest));
      game.quest = btoa(area.value);      
      //getElement('quest').innerHTML = atob(game.quest);      
      area.blur();
      editor.dialogMethod = null;
      update = true;
      editor.saveGame();
    };
    /**
    @method showQuestDialog
    */
    editor.showQuestDialog = function() {
      area.value = atob(game.quest);
      area.focus();
      editor.dialogMethod = 'setQuest';
    };
    /**
    @method setTitle
    */
    editor.setTitle = function() {      
      game.title = btoa(area.value);
      //getElement('title').innerHTML = atob(game.title);          
      area.blur();
      editor.dialogMethod = null;
      update = true;
      editor.saveGame();
    };
    /**
    @method showTitleDialog
    */
    editor.showTitleDialog = function() {
      area.value = atob(game.title);
      area.focus();
      editor.dialogMethod = 'setTitle';
    };
    /**
    a test and play method
    @method playGame
    */
    editor.playGame = function() {
      editor.saveGame();
      editor.oldGame = game;
      //new game instance
      game = editor.loadGame();
      win.canvas = getElement('canvas');
      if (canvas == null) {
        canvas = createElement('canvas');
      } else {
        body.removeChild(canvas);
      }
      var w = window.innerWidth;
      var h = window.innerHeight;
      //test
      w > 420 ? w = 420: w = w;
      //replace this once if everything will be canvas based including the editor
      canvas.width = w < h ? w : h;
      canvas.height = w < h ? w : h;
      canvas.style.width = canvas.width+'px';
      canvas.style.height = canvas.height+'px';
      win.ctx = canvas.getContext('2d');
      canvas.style.position='absolute';
      canvas.style.left=0;
      canvas.style.top=0;
      canvas.style.background='rgba(255,255,255,0.75)';
      getElement('playbutton').value='stop';
      getElement('playbutton').setAttribute('onclick' , 'editor.stopGame();');
      body.appendChild(canvas);
      game.init();
    };
    /**
    stop the play test
    @method stopGame
    */
    editor.stopGame = function() {
      //restore the old game instance
      game = editor.oldGame;
      editor.oldGame = null;
      canvas.style.display = 'none';
      getElement('playbutton').value='play';
      getElement('playbutton').setAttribute('onclick' , 'editor.playGame();');
    };
    /**
    @method newGame
    */
    editor.newGame = function() {
      var value = confirm('Do you realy want to delete the game?');
      console.log(value);
      if (value!=true)
      {
        return;
      }
      game = new Game();
      game.objects = [];
      game.start = null;
      game.end = null;
      game.quest = null;
      game.title = null;
      game.order = [];
      for (var i = 0; i < 4; i++)
      {
        for (var j = 0; j < 4; j++)
        {
          ele = getElement('o_'+i+'_'+j);
          ele.className = 'grid-element';
          game.objects.push(new GameObject(ele.id, null) );
        }
      }
      getElement('output').innerHTML = '';
      editor.saveGame();
    };
    /**
    the method might provide an empty game,
    if the store is not enabled
    @method loadGame
    @return an initialized instance of game
    */
    editor.loadGame = function() {
      var g = new Game();
      var data = null;
      try {
        data = JSON.parse(store.getItem('gridStoryGame'));
      } catch(ex) {
        console.log(ex);
      }
        g.objects = [];
        var obj = null;
        if (data != null)
        for (var i = 0; i < data['objects'].length; i++)
        {
          obj = new GameObject();
          obj.load(data['objects'][i]);
          g.objects.push(obj);
        }
        g.dependencies = [];
        if (data != null)
        if (data['dependencies']!= null) {
          for (var i = 0; i < data['dependencies'].length; i++) {
            var d = new GameDependency();
            d.load(data['dependencies'][i]);
            g.dependencies.push(d);
          }
        }
        g.order = [];
        if (data != null) {
          g.start = data['start'];
          g.end = data['end'];
          g.quest = data['quest'];
          g.title = data['title'];
        } else {
          g.start = null;
          g.end = null;
          g.quest = null;
          g.title = null;
        }
      /*}
      catch (ex) {
        console.log(ex);
      }*/
      return g;
    };
    /**
    @method closeMenu
    */
    editor.closeMenu = function() {
      menuMode = false;
    };
    /**
    @method setCurrentObject
    */
    editor.setCurrentObject = function(id) {
      /*var ele = null
      if (editor.current != null) {
        ele = getElement(''+editor.current);
        ele.className = ele.className.replace(/ grid-current/g, '');
        ele.setAttribute('onclick','editor.setText(\''+ele.id+'\',null);');
      }*/
      editor.currentObject = editor.getObject(id);
      /*ele = getElement(''+id);
      ele.className = ele.className+' grid-current';
      ele.setAttribute('onclick','editor.setOrderAndEvents(\''+ele.id+'\');');*/
    };
    /**
    @method showOrderAndEventsPrompt
    */
    editor.showOrderAndEventsPrompt = function(obj_id) {
      if (editor.currentObject != null)
      {
        obj_id = editor.currentObject.id;
      } else {
        alert('Please, select an object first!');
        return;
      }
      var obj = game.getObject(obj_id);
      var prompt = getElement('prompt');
      //alert('prompt: '+prompt);
      if (prompt == null)
      {
        prompt = createElement('div');
        prompt.className = 'prompt';
        prompt.setAttribute('id','prompt');
        body.appendChild(prompt);
      }
      prompt.innerHTML = '';
      var ele = createElement('button');
      ele.setAttribute('onclick','getElement(\'prompt\').style.display=\'none\';');
      ele.appendChild(createTextNode('close'));
      prompt.appendChild(ele);
      prompt.appendChild(createElement('br'));
      prompt.appendChild(createTextNode('order'));
      prompt.appendChild(createElement('br'));
      var span = createElement('input');
      span.style.marginRight='1px';
      span.style.display='inline-block';
      span.style.minWidth='40px';
      span.style.border = 'solid 1px #999';
      span.setAttribute('id','input_ord_'+obj.id);
      span.value = obj.order;
      prompt.appendChild(span);
      prompt.appendChild(createElement('br'));
      prompt.appendChild(createTextNode('event: showObject([object id]), hideObject([object id]), showText([a text])'));
      prompt.appendChild(createElement('br'));
      span = createElement('button');
      span.appendChild(createTextNode('add event'));
      span.setAttribute('onclick', 'editor.addEvent(\''+obj.id+'\');');
      prompt.appendChild(span);
      span = createElement('div');
      span.style.marginRight='1px';
      span.style.display='inline-block';
      span.style.minWidth='90%';
      span.style.maxWidth='90%';
      span.style.border = 'solid 1px #999';
      span.setAttribute('id','div_events');
      prompt.appendChild(span);
      var methods = ['showText','showObject','hideObject'];
      //console.log(''+obj.events.length);
      for (var i = 0; i < obj.events.length; i++) {
        var ele = createElement('select');
        ele.setAttribute('id', 'eve_method_'+i);
        ele.style.cssFloat='left';
        for (var j = 0; j < methods.length; j++) {
          var opt = createElement('option');
          opt.value = methods[j];
          opt.appendChild(createTextNode(methods[j]));
          ele.appendChild(opt);
        }
        ele.style.width='48%';
        ele.value = obj.events[i].method;
        span.appendChild(ele);
        ele = createElement('input');
        ele.setAttribute('id', 'eve_values_'+i);
        ele.style.cssFloat='left';
        ele.style.width = obj.events[i].method=='showText' ? '98%':'48%';
        ele.value =
            obj.events[i].method=='showText' ? atob(obj.events[i].values) : obj.events[i].values;
        span.appendChild(ele);
        ele = createElement('br');
        ele.style.clear = 'both';
        span.appendChild(ele);
        span.appendChild(createElement('hr'));
      }
      prompt.appendChild(createElement('br'));
      prompt.appendChild(createElement('hr'));
      span = createElement('button');
      span.appendChild(createTextNode('set order, events, dependencies'));
      span.setAttribute('onclick','editor.setOrderAndEvents(\''+obj.id+'\');');
      prompt.appendChild(span);
      prompt.appendChild(createElement('br'));
      prompt.style.display='block';
    };
    /**
    @method addEvent
    */
    editor.addEvent = function(obj_id) {
      var obj = game.getObject(obj_id);
      //the current object
      //the prompt scoll element-div
      var ele = getElement('div_events');
      //add a new event div
      var span = createElement('select');
      span.setAttribute('id', 'eve_method_'+obj.events.length);
      span.style.cssFloat='left';
      var methods = ['showText','showObject','hideObject'];
      for (var j = 0; j < methods.length; j++) {
        var opt = createElement('option');
        opt.value = methods[j];
        opt.appendChild(createTextNode(methods[j]));
        ele.appendChild(opt);
      }
      span.style.width='48%';
      span.setAttribute('placeholder','method');
      ele.appendChild(span);
      span = createElement('input');
      span.setAttribute('id', 'eve_values_'+obj.events.length);
      span.style.cssFloat='left';
      span.style.width='48%';
      span.setAttribute('placeholder','value');
      ele.appendChild(span);
      ele.appendChild(createElement('hr'));
      obj.events.push(new GameEvent());
    };
    /**
    @method showDependenciesPrompt
    */
    editor.showDependenciesPrompt = function(obj) {
      var prompt = getElement('prompt');
      //alert('prompt: '+prompt);
      if (prompt == null)
      {
        prompt = createElement('div');
        prompt.className = 'prompt';
        prompt.setAttribute('id','prompt');
        body.appendChild(prompt);
      }
      prompt.innerHTML = '';
      var ele = createElement('button');
      ele.setAttribute('onclick','getElement(\'prompt\').style.display=\'none\';');
      ele.appendChild(createTextNode('close'));
      prompt.appendChild(ele);
      prompt.appendChild(createElement('br'));
      prompt.appendChild(createTextNode('dependencies: isSmaller, hasMissed'));
      prompt.appendChild(createElement('br'));
      prompt.appendChild(createTextNode('{priority: 0, method:\'isSmaller\', text: \'show this text\', params: [a,b]}'));
      prompt.appendChild(createElement('br'));
      prompt.appendChild(createTextNode('{priority: 1, method:\'hasMissed\', text: \'show this text because of the higher priority\', params: [a]}'));
      prompt.appendChild(createElement('br'));
      ele = createElement('div');
      var dependencies = game.dependencies;
      //console.log(dependencies.length);
      for (var i = 0; i < dependencies.length; i++) {
        ele.appendChild(createTextNode('priority: '));
        span = createElement('input');
        //span.style.cssFloat='left';
        //console.log(dependencies[i]);
        span.style.marginRight='1px';
        span.style.display='inline-block';
        span.style.minWidth='10%';
        span.style.maxWidth='10%';
        span.style.border = 'solid 1px #999';
        span.setAttribute('id','depend_priority_'+i);
        span.value = dependencies[i].priority;
        ele.appendChild(span);
        ele.appendChild(createTextNode(' method: '));
        span = createElement('input');
        span.setAttribute('type', 'radio');
        span.style.marginRight='1px';
        span.style.display='inline-block';
        span.style.border = 'solid 1px #999';
        span.setAttribute('id','depend_smaller_'+i);
        dependencies[i].method=='isSmaller'? span.checked=true : span.value='';
        ele.appendChild(span);
        ele.appendChild(createTextNode(' isSmaller '));
        span = createElement('input');
        span.setAttribute('type', 'radio');
        span.style.marginRight='1px';
        span.style.display='inline-block';
        span.style.border = 'solid 1px #999';
        span.setAttribute('id','depend_missed_'+i);
        dependencies[i].method=='hasMissed' ? span.checked=true : span.value='';
        ele.appendChild(span);
        ele.appendChild(createTextNode(' hasMissed'));
        //need a unselect button here for no issmaller and no hasmissed
        ele.appendChild(createElement('br'));
        ele.appendChild(createTextNode('text: '));
        span = createElement('input');
        //span.style.cssFloat='left';
        span.style.marginRight='1px';
        span.style.display='inline-block';
        span.style.minWidth='70%';
        span.style.maxWidth='70%';
        span.style.border = 'solid 1px #999';
        span.setAttribute('id','depend_text_'+i);
        span.value = atob(dependencies[i].text);
        ele.appendChild(span);
        ele.appendChild(createElement('br'));
        ele.appendChild(createTextNode('params: '));
        var dmax = dependencies[i].method == 'hasMissed' ? 1 : 2;
        for (var j = 0; j < dmax; j++) {
          span = createElement('select');
          span.style.marginRight='1px';
          span.style.display='inline-block';
          span.style.minWidth='40%';
          span.style.maxWidth='40%';
          span.style.border = 'solid 1px #999';
          span.setAttribute('id','depend_params_'+i+'_'+j);
          var option = null;
          //set the selected value and avoid the selected object
          for (var k = 0; k < game.objects.length; k++)
          {
            option = createElement('option');
            option.value = game.objects[k].id;
            option.appendChild(createTextNode(game.objects[k].id));
            span.appendChild(option);
            if (dependencies[i].method == 'hasMissed' && dependencies[i].params[0] == game.objects[k].id) {
              option.setAttribute('selected', 'true');
            }
          }
          ele.appendChild(span);
        }
        ele.appendChild(createElement('hr'));
      }
      //console.log('hello');
      ele.setAttribute('id','dependencies');
      prompt.appendChild(ele);
      span = createElement('button');
      span.appendChild(createTextNode('add dependency'));
      span.setAttribute('onclick','editor.addDependency();');
      prompt.appendChild(span);
      prompt.appendChild(createElement('br'));
      prompt.appendChild(createElement('hr'));
      span = createElement('button');
      span.appendChild(createTextNode('set dependencies'));
      span.setAttribute('onclick','editor.setDependencies();');
      prompt.appendChild(span);
      prompt.appendChild(createElement('br'));
      prompt.style.display='block';
    };
    /**
    adds a single empty denpency to the element dependencies and the array
    @method addDependency
    */
    editor.addDependency = function() { //obj_id) {
      var dependencies = game.dependencies;
      var ele = getElement('dependencies');
      ele.appendChild(createTextNode('priority: '));
      span = createElement('input');
      //span.style.cssFloat='left';
      span.style.marginRight='1px';
      span.style.display='inline-block';
      span.style.minWidth='10%';
      span.style.maxWidth='10%';
      span.style.border = 'solid 1px #999';
      span.setAttribute('id','depend_priority_'+dependencies.length);
      span.value = '';
      ele.appendChild(span);
      ele.appendChild(createTextNode(' method: '));
      span = createElement('input');
        span.setAttribute('type', 'radio');
        span.style.marginRight='1px';
        span.style.display='inline-block';
        span.style.border = 'solid 1px #999';
        span.setAttribute('id','depend_smaller_'+dependencies.length);
        //dependencies[i].method == 'isSmaller' ? span.checked=true : span.value='';
        ele.appendChild(span);
        ele.appendChild(createTextNode(' isSmaller '));
      span = createElement('input');
        span.setAttribute('type', 'radio');
        span.style.marginRight='1px';
        span.style.display='inline-block';
        span.style.border = 'solid 1px #999';
        span.setAttribute('id','depend_missed_'+dependencies.length);
        //dependencies[i].method == 'hasMissed' ? span.checked=true : span.value='';
        ele.appendChild(span);
        ele.appendChild(createTextNode(' hasMissed'));
      ele.appendChild(createElement('br'));
      ele.appendChild(createTextNode('text: '));
      span = createElement('input');
      //span.style.cssFloat='left';
      span.style.marginRight='1px';
      span.style.display='inline-block';
      span.style.minWidth='70%';
      span.style.maxWidth='70%';
      span.style.border = 'solid 1px #999';
      span.setAttribute('id','depend_text_'+dependencies.length);
      span.value = '';
      ele.appendChild(span);
      ele.appendChild(createElement('br'));
      ele.appendChild(createTextNode('params: '));
      for (var j = 0; j < 2; j++) {
        span = createElement('select');
        //span.style.cssFloat='left';
        span.style.marginRight='1px';
        span.style.display='inline-block';
        span.style.minWidth='40%';
        span.style.maxWidth='40%';
        span.style.border = 'solid 1px #999';
        span.setAttribute('id','depend_params_'+dependencies.length+'_'+j);
        span.setAttribute('name','depend_params_'+dependencies.length+'_'+j);
        var option = null;
        //
        for (var k = 0; k < game.objects.length; k++)
        {
          option = createElement('option');
          option.value = game.objects[k].id;
          option.appendChild(createTextNode(game.objects[k].id));
          span.appendChild(option);
        }
        ele.appendChild(span);
      }
      ele.appendChild(createElement('hr'));
      dependencies.push({priority:'',method:'',text:'',params:[]});
      //var d = new GameDependency(0,null,[]);
      //dependencies.push(d);
    };
    /**
    read the input values of the dendencies element and sets the values in the dependencies array
    is saving the game
    @method setDependencies
    */
    editor.setDependencies = function() {
      var dependencies = game.dependencies;
      //set the selected value and avoid the selected object
      for (var i = 0; i < dependencies.length; i++)
      {
        //
        var input = getElement('depend_priority_'+i).value;
        dependencies[i].priority = input;
        input = getElement('depend_text_'+i).value;
        dependencies[i].text = btoa(input);
        //it's a radio button!
        input = getElement('depend_missed_'+i).checked ? 'hasMissed' : 'isSmaller';
        console.log(input);
        dependencies[i].method = input;
        dependencies[i].params = [];
        var j = 0;
        var ele = getElement('depend_params_'+i+'_'+j);
        while (ele != null && j < game.objects.length)
        {
          console.log(ele);
          dependencies[i].params.push(ele.value);
          j++;
          ele = getElement('depend_params_'+i+'_'+j);
        }
      }
      editor.saveGame();
      console.log(game.dependencies);
      getElement('prompt').style.display = 'none';
    };
    /**
    @method setEvent
    */
    editor.setEvent = function(id) {
      var obj = game.getObject(id);
      var code = prompt('add some event code: showObject, hideObject, showText', obj.event==null?'':atob(obj.event) );
      //editor.showPrompt(obj);
      if (code != '')
      {
        obj.setEvent(code);
        //editor.setDependecies(obj);
        editor.saveGame();
      }
    };
    /**
    @method setEnd
    */
    editor.setStart = function() {
      if (editor.currentObject == null)
      {
        alert('Select an object first.');
        menuMode = false;
        update = true;
        return;
      }
      //alert('The next click will set the start object.');
      editor.mode='setstart';
      editor.setText(editor.currentObject.id);
      menuMode = false;
      update = true;
    };
    /**
    @method setEnd
    */
    editor.setEnd = function() {
      if (editor.currentObject == null)
      {
        alert('Select an object first.');
        menuMode = false;
        update = true;
        return;
      }
      //alert('The next click will set the end object.');
      editor.mode='setend';
      editor.setText(editor.currentObject.id);
      menuMode = false;
      update = true;
    };
    var keyup = function(eve) {
      if (gmode == 'editor') {
          editor.keyup(eve);
        } else {
          //game.keyup(eve);
        }
    };
    /**
    an general method
    @method updateDraw
    */
    var updateDraw = function() {
      if (update) {
        if (gmode == 'editor') {
          editor.draw();
        } else {
          game.draw();
        }
        update = false;
      }
      requestAnimationFrame(function() { updateDraw(); } );
    };
    /**
    an editor method
    @method updateDraw
    */
    editor.draw = function() {
      var cw = canvas.width;
      var ch = canvas.height;
      ctx.fillStyle = '#eee';
      ctx.fillRect(0,0,cw,ch);
      ctx.fillStyle = '#000';
      var fts = Math.round(0.035*cw);
      ctx.font = fts+'px Sans-Serif';
      var objects = game.objects;
      var obj = null;
      /*if (typeof btx == 'undefined' || btx == null)
      {
        bufferImg = createElement('canvas');
        bufferImg.width = 420;
        bufferImg.height = 420;
        btx = bufferImg.getContext('2d');
        cw = bufferImg.width;
        ch = bufferImg.height;
      }*/
      //game or editor
        console.log(ch,ch*0.95);
        ctx.fillText(''+atob(game.title),0.02*cw,ch*editor.inputs[0].pos);
        ctx.fillText(''+atob(game.quest),0.02*cw,ch*editor.inputs[1].pos);
        if (editor.currentObject != null)
        {
          ctx.fillText(editor.currentObject.id+':',0.02*cw,ch*editor.inputs[2].pos);
          ctx.fillText(''+atob(editor.currentObject.text),0.2*cw,ch*editor.inputs[2].pos);
          ctx.fillText('order: '+editor.currentObject.order,0.02*cw,ch*editor.inputs[3].pos);
        }
        //begin of btx context
        btx.lineWidth = 0.025 * cw;
        btx.fillStyle = '#ddd';
        btx.fillRect(0,0,cw,cw);
        //alert('objects.length='+objects.length);
        for (var i = 0; i < objects.length; i++)
        {
          obj = objects[i];
            if (obj.id == game.start)
            {
              btx.fillStyle = '#0c0';
              btx.strokeStyle = '#000';
            } else if (obj.id == game.end)
            {
              if (obj.active)
              {
                btx.fillStyle = '#c00';
                btx.strokeStyle = '#000';
              } else {
                btx.fillStyle = 'rgba(204,51,51,0.5)';
                btx.strokeStyle = 'rgba(51,51,51,0.5)';
              }
            } else if (obj.active)
            {
              btx.fillStyle = '#99c';
              btx.strokeStyle = '#000';
            } else {
              btx.fillStyle = 'rgba(128,128,205,0.5)';
              btx.strokeStyle = 'rgba(51,51,51,0.5)';
            }
            if (editor.currentObject != null && obj.id == editor.currentObject.id) {
              btx.strokeStyle = '#f90';
              //btx.fillStyle = 'rgba(255,204,128,0.7)';
            }
            btx.fillRect(obj.x * cw, obj.y * cw, obj.w * cw, obj.h * cw);
            btx.strokeRect(obj.x * cw, obj.y * cw, obj.w * cw, obj.h * cw);
            btx.font = fts+'px Sans-Serif';
            btx.fillStyle = '#000';
            btx.fillText(''+obj.id, obj.x * cw + 0.02 * cw, obj.y * cw + fts * 1.2);
            btx.fillText(''+obj.order, obj.x * cw + 0.02 * cw, obj.y * cw + fts * 2.4);

        }
        ctx.drawImage(bufferImg, 0, (canvas.height-cw)/2, cw, cw);
      //draw menu, inputs, prompts and selects here
      if (menuMode) {
        ctx.fillStyle = 'rgba(25,25,25,0.5)';
        ctx.fillRect(0,0,cw,ch);
        ctx.fillStyle = 'rgba(255,255,255,0.85)';
        ctx.fillRect(cw/2,0,cw/2,ch);
        ctx.fillStyle = '#000';
        var h = fts * 1.5;
        for (var i = 0; i < editor.buttonLabels.length; i++) {
          /*if (editor.buttonLabels[i] instanceof Array) {
            for (var j = 0; j < editor.buttonLabels[i].length; j++) {
              ctx.fillText(editor.buttonLabels[i][j].text, cw / 2 + 0.055 * cw, h);
              ctx.fillRect(cw / 2 + 0.05 * cw, h + fts * 0.1, cw / 2 - 0.1 * cw, 1);
              h += fts * 1.5;
            }
          } else {*/
            ctx.fillText(editor.buttonLabels[i].text, cw / 2 + 0.03 * cw, h);
            ctx.fillRect(cw / 2 + 0.025 * cw, h + fts * 0.1, cw / 2 - 0.05 * cw, 1);
            h += fts * 1.5;
          //}
        }
      }
      console.log('editor.draw->'+objects.length);
    };
    /**
    @method keypress
    */
    editor.keypress = function(eve)  {
    
    };
    /**
    @method keyup
    */
    editor.keyup = function(eve)  {
      var keycode = (typeof eve.key == 'undefined' ? eve.which : eve.key.toLowerCase());
      console.log('keycode -> '+keycode);
        //alert('keycode -> '+keycode);
        //ctx.fillText('keycode -> '+(keycode), 5, 20);
      if (keycode == 'enter' || keycode == 13) {
          //set the name of the currentObject, Scene or a dialogline
          //also the game.title
          editor[editor.dialogMethod]();
      } else {
          console.log('keycode -> '+keycode);
          //editor.area.focus();
      }
      //editor.text = area.value;
      console.log('editor.text->'+area.value);
      update = true;
    };
    /**
    @method mousePressed
    */
    editor.mousePressed = function(_x, _y) {
      if (!pressed)
      {
        mend = false;
        pressed = true;
        px = _x;
        py = _y;
        mx = _x;
        my = _y;
        if (!menuMode)
        {
          if (mouseTimer == null)
          {
            mouseTimer = setTimeout( function() {
                if (mouseTimer != null)
                {
                  console.log('long press');
                  //editor.showMenu();
                  menuMode = true;
                  update = true;
                }
              }
            , 1000);
          }
          /*
          if (!editor.objectMode)
          {
            editor.currentObject = new GameObject(editor.createUid(), px, py);
          }*/
        }
        update = true;
      }
    };
    /**
    @method mouseMoved
    */
    editor.mouseMoved = function(_x, _y) {
      if (pressed)
      {
        if (!menuMode)
        {
          //use for scrolling or painting features
          //console.log(_x+','+_y);
          /*
          if (editor.objectMode)
          {
            editor.currentObject.bounds.x = _x;
            editor.currentObject.bounds.y = _y;
          } else if (editor.currentObject != null)
          {
            if (_x < editor.currentObject.bounds.x)
            {
              editor.currentObject.bounds.w = editor.currentObject.bounds.x - _x;
              editor.currentObject.bounds.x = _x;
            } else {
              editor.currentObject.bounds.w = _x - editor.currentObject.bounds.x;
            }
            if (_y < editor.currentObject.bounds.y)
            {
              editor.currentObject.bounds.h = editor.currentObject.bounds.y - _y;
              editor.currentObject.bounds.y = _y;
            } else {
              editor.currentObject.bounds.h = _y - editor.currentObject.bounds.y;
            }
          }*/
          if (mouseTimer != null && (mx<=px-0.01 || my<=py-0.012 || mx>=px+0.01 || my>=py+0.012))
          {
            clearTimeout(mouseTimer);
            mouseTimer = null;
          }
        }
        //update = true;
      }
    };
    /**
    @method mouseReleased
    */
    editor.mouseReleased = function(x, y) {
      if (pressed)
      {
        if (!menuMode)
        {
          if (mouseTimer != null)
          {
            clearTimeout(mouseTimer);
            mouseTimer = null;
          }
          if ((x>=px+0.01 && y>=py+0.012) && editor.currentObject != null)
          {
            //you can move the current object here (release)
          } else {
            //editor.inputs -> edit text
            var cw = canvas.width;
            var fts = 0.035;
            //console.log(editor.inputs,fts);
            for (var i = 0; i < editor.inputs.length; i++)
            {
              console.log('e.in', fts + editor.inputs[i].pos,y,editor.inputs[i].pos,'puts');
              if (y > (editor.inputs[i].pos - fts) && y < (editor.inputs[i].pos))
              {
                console.log(editor.inputs[i]);
                editor[editor.inputs[i].onclick]();
                return;
              }
            }
            //not moving
            //edit object if is Hit
            //object text and order edit
            console.log(x+' '+y+'~'+game.objects.length);
            var yo = (y - 0.125)* canvas.height / bufferImg.height;
            var obj = null;
            for (var i = 0; i < game.objects.length; i++)
            {
              obj = game.objects[i];
              //console.log(i+'-'+obj.x+' '+(obj.x+obj.w)+', '+obj.y+' '+(obj.y+obj.h))
              if (obj.pointHits(x,yo))
              {
                editor.currentObject = obj;
                px = 0;
                py = 0;
                mx = 0;
                my = 0;
                pressed = false;
                update = true;
                return;
              }
            }
          }
        } else {
          //look for buttons
          if (mouseTimer != null)
          {
            clearTimeout(mouseTimer);
            mouseTimer = null;
          } else {
            //menu here
            var fts = 0.035;
            var h = 0;//fts * 1.2;
            //console.log(x,y,editor.buttonLabels);
            for (var i = 0; i < editor.buttonLabels.length; i++)
            {
              //missing array here!
              console.log((h)+', '+y+', '+(h + fts * 1.2));
              if (x>0.5 && y > h  && y < (h + fts * 1.2))
              {
                console.log(editor.buttonLabels[i]);
                editor[editor.buttonLabels[i].onclick]();
                //menuMode = false;
              }
              h += fts * 1.2;
            }
            //menu ends
            //menuMode = false;
          }
        }
        //update & draw doublebuffer
        px = 0;
        py = 0;
        mx = 0;
        my = 0;
        pressed = false;
        update = true;
      }
    };
    /**
    */
    editor.createUid = function() {
      var abc = 'abcdefghijklmnopqrstuvwxyz1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ';
      var uid = '';
      while (uid.length < editor.uidMax || editor.hasUid(uid)) {
         uid = '';
         for (var i = 0; i < editor.uidMax; i++)
         {
           uid = uid + abc.substr(Math.floor(Math.random()*abc.length), 1);
         }
         if (!isNaN(uid))
         {
           uid = '_'+uid;
         }
      }
      editor.addUid(uid);
      return uid;
    };
    /**
    @method
    */
    var mousePressed = function(x,y) {
      if (gmode == 'editor') {
        editor.mousePressed(x,y);
      } else {
        game.mousePressed(x,y);
      }
    };
    /**
    @method
    */
    var mouseMoved = function(x,y) {
      if (gmode == 'editor') {
        editor.mouseMoved(x,y);
      } else {
        game.mouseMoved(x,y);
      }
    };
    /**
    @method
    */
    var mouseReleased = function(x,y) {
      if (gmode == 'editor') {
        editor.mouseReleased(x,y);
      } else {
        game.mouseReleased(x,y);
      }
    };
    /**
    editor method
    @method init
    */
    editor.init = function() {
      //game = new Game();
      game = editor.loadGame();
      canvas = getElement('canvas');
      if (canvas == null) {
        canvas = createElement('canvas');
      } else {
        body.removeChild(canvas);
      }
      var w = window.innerWidth;
      var h = window.innerHeight;
      //test
      w > 420 ? w = 420: w = w;
      h > 560 ? h = 560: h = h;
      //replace this once if everything will be canvas based including the editor
      canvas.width = w;//w < h ? w : h;
      canvas.height = h;//w < h ? w : h;
      canvas.style.width = canvas.width+'px';
      canvas.style.height = canvas.height+'px';
      //win.ctx = canvas.getContext('2d');
      //canvas.style.position='absolute';
      canvas.style.left=0;
      canvas.style.top=0;
      canvas.style.background='rgba(255,255,255,0.75)';
      //canvas.style.position='absolute';
      canvas.style.top = '0';
      canvas.style.left = '0';

      //getElement('playbutton').value='stop';
      //getElement('playbutton').setAttribute('onclick' , 'editor.stopGame();');
      body.appendChild(canvas);
      ctx = canvas.getContext('2d');
      for (var i = 0; i < 4; i++)
      {
        for (var j = 0; j < 4; j++)
        {
          ele = createElement('div');
          ele.className = 'grid-element';
          ele.setAttribute('id','o_'+i+'_'+j);
          ele.setAttribute('onclick','editor.setText(\''+ele.id+'\',null);');
          //ele.appendChild(createTextNode(' '+ele.id));
          //ele.appendChild(createTextNode(' '+obj.order));
          if (game.getObject('o_'+i+'_'+j)==null)
          {
            var obj = new GameObject('o_'+i+'_'+j, null);
            //game.objects.push({text:'',order: 0, id:ele.id, event: null});
            obj.x = 0.04 + j * 0.24;//canvas.width/40 + j * canvas.width/4.5;
            obj.y = 0.04 + i * 0.24;//canvas.width/8 + i * canvas.width/4.5;
            obj.w = obj.h = 0.2;//canvas.width/6;
            obj.ox = obj.x;
            obj.oy = obj.y;
            game.objects.push(obj);
          } else {
            var obj = game.getObject('o_'+i+'_'+j);
            obj.x = 0.04 + j * 0.24;//canvas.width/40 + j * canvas.width/4.5;
            obj.y = 0.04 + i * 0.24;//canvas.width/8 + i * canvas.width/4.5;
            obj.w = obj.h = 0.2;//canvas.width/6;
            obj.ox = obj.x;
            obj.oy = obj.y;
          }
          body.appendChild(ele);
        }
        //ele = createElement('br');
        //ele.style.clear='both';
        //body.appendChild(ele);
      }
      bufferImg = createElement('canvas');
      bufferImg.width = canvas.width;//400|800|1200|1600|2000|2400
      bufferImg.height = canvas.width;//225|450|675|900|1125|1350
      btx = bufferImg.getContext('2d');
        //add the touch and mouselisteners to the canvas now.
        if ('ontouchstart' in window)
        {
          console.log('using touch');
          canvas.addEventListener('touchstart',
          function(eve) {
            eve.preventDefault();
            mousePressed(eve.touches[0].pageX/canvas.width,eve.touches[0].pageY/canvas.height);
          },
          false);
          canvas.addEventListener('touchmove',
          function(eve) {
            eve.preventDefault();
            mx = eve.touches[0].pageX/canvas.width;
            my = eve.touches[0].pageY/canvas.height;
            mouseMoved(mx,my);
          },
          false);
          canvas.addEventListener('touchend',
          function(eve) {
            eve.preventDefault();
            if (!mend) {
              mend = true;
              mouseReleased(mx, my);
            }
          },
          false);/*
          canvas.addEventListener('touchcancel',
          function(eve) {
            eve.preventDefault();
            if (!mend) {
              mend = true;
              mouseReleased(mx, my);
            }
          },
          false);*/
        } //else {
          canvas.addEventListener('mousedown',
          function(eve) {
            mousePressed(eve.pageX/canvas.width,eve.pageY/canvas.height);
          },
          false);
          canvas.addEventListener('mousemove',
          function(eve) {
            mx = eve.pageX/canvas.width;
            my = eve.pageY/canvas.height;
            mouseMoved(mx,my);
          },
          false);
          canvas.addEventListener('mouseup',
          function(eve) {
            mouseReleased(eve.pageX/canvas.width,eve.pageY/canvas.height);
          },
          false);
      //adding invisible textarea
      area = createElement('textarea');
      area.addEventListener('keyup',function(eve) { keyup(eve); },true);
      area.style.position = 'absolute';
      area.style.top = '-2px';
      area.style.left = '-2px';
      area.style.border = 0;
      area.style.fontSize = '1px';//this must be fts+'px'
      area.style.opacity = '0.01';
      area.style.color = 'transparent';
      area.style.width = '1px';
      area.style.height = '1px';
      body.appendChild(area);
      //adding invisible textarea
      var ele = null;

      editor.inputs = [];
      editor.inputs.push({name:'title',text:game.title==null?'click to edit title.':atob(game.title),onclick:'setTitle',pos:0.04});
      editor.inputs.push({name:'quest',text:game.quest==null?'click and enter quest.':atob(game.quest),onclick:'setQuest',pos:0.08});
      editor.inputs.push({name:'currentObject',text:'current object text',onclick:'setText',pos:0.92});
      editor.inputs.push({name:'order',text:'order number',onclick:'showOrderAndEventsPrompt',pos:0.96});

      for (var i = 0; i < game.objects.length; i++)
      {
        var obj = game.objects[i];
        if (obj.text != null && obj.text != '')
        {
          editor.setText(obj.id, obj.getText());
        }
      }
      gmode = 'editor';
      //request animation frame
      update = true;
      requestAnimationFrame(function() {updateDraw();} );
    };    

    win.game = game;
    win.editor = editor;
    window.onload = function() {setTimeout(editor.init(), 100);};
  })(window)
  </script>
 </body>
</html>

